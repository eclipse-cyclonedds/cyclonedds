/*
 * Copyright(c) 2006 to 2020 ADLINK Technology Limited and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
 * v. 1.0 which is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
 */
#ifndef IDL_H
#define IDL_H

#include <stdarg.h>

#include "dds/ddsrt/attributes.h"
#include "dds/ddsrt/retcode.h"

#include "dds/ddsts/typetree.h"
#include "tt_create.h"

/** @private */
typedef struct idl_file idl_file_t;
struct idl_file {
  idl_file_t *next;
  char *name;
};

/** @private */
typedef struct idl_buffer idl_buffer_t;
struct idl_buffer {
  char *data;
  size_t size; /**< total number of bytes available */
  size_t used; /**< number of bytes used */
};

/** @private */
typedef struct idl_position idl_position_t;
struct idl_position {
  const char *file;
  uint32_t line;
  uint32_t column;
};

/** @private */
typedef struct idl_location idl_location_t;
struct idl_location {
  idl_position_t first;
  idl_position_t last;
};

/** @private */
typedef struct idl_lexeme idl_lexeme_t;
struct idl_lexeme {
  const char *marker;
  const char *limit;
  idl_location_t location;
};

/** @private */
typedef struct idl_token idl_token_t;
struct idl_token {
  int32_t code; /**< token identifier (generated by Bison) */
  union {
    int32_t chr;
    long long llng;
    unsigned long long ullng;
    char *str;
  } value;
  idl_location_t location;
};

/** @private */
typedef struct idl_scanner idl_scanner_t;
struct idl_scanner {
  const char *cursor;
  const char *limit;
  idl_position_t position;
};

/** @private */
typedef struct idl_directive idl_directive_t;
struct idl_directive {
  enum { IDL_LINE, IDL_KEYLIST } type;
};

/** @private */
typedef struct idl_line idl_line_t;
struct idl_line {
  idl_directive_t directive;
  uint32_t line;
  char *file;
  bool extra_tokens;
};

/** @private */
typedef struct idl_keylist idl_keylist_t;
struct idl_keylist {
  idl_directive_t directive;
  char *data_type;
  char **keys;
};

/** @private */
typedef struct idl_parser idl_parser_t;
struct idl_parser {
  void *yypstate; /**< state of Bison generated parser */
};

/**
 * @name processor_options
 * IDL processor options
 * @{
 */
/** Debug */
#define IDL_FLAG_DEBUG (1u<<1)
/** Preprocess */
#define IDL_PREPROCESS (1u<<0)

#define IDL_WRITE (1u<<11)
/** @} */

/** @private */
typedef struct idl_processor idl_processor_t;
struct idl_processor {
  uint32_t flags; /**< processor options */
  enum {
    IDL_SCAN,
    /** scanning preprocessor directive */
    IDL_SCAN_DIRECTIVE = (1<<7),
    IDL_SCAN_DIRECTIVE_NAME,
    /** scanning #line directive */
    IDL_SCAN_LINE = (IDL_SCAN_DIRECTIVE | 1<<6),
    IDL_SCAN_FILENAME,
    IDL_SCAN_EXTRA_TOKEN,
    /** scanning #pragma directive */
    IDL_SCAN_PRAGMA = (IDL_SCAN_DIRECTIVE | 1<<5),
    IDL_SCAN_UNKNOWN_PRAGMA,
    /** scanning #pragma keylist directive */
    IDL_SCAN_KEYLIST = (IDL_SCAN_PRAGMA | 1<<4),
    IDL_SCAN_DATA_TYPE,
    IDL_SCAN_KEY,
    /** scanning IDL code */
    IDL_SCAN_CODE = (1<<9),
    /** scanning a scoped name in IDL code */
    IDL_SCAN_SCOPED_NAME = (IDL_SCAN_CODE | (1<<8)),
    /** end of input */
    IDL_EOF = (1<<10)
  } state; /**< processor state */
  idl_file_t *files; /**< list of encountered files */
  idl_directive_t *directive; /**< */
  idl_buffer_t buffer; /**< dynamically sized input buffer */
  idl_scanner_t scanner;
  idl_parser_t parser;
  ddsts_context_t *context;
};

#define IDL_PUSH_MORE (-1)
#define IDL_NEED_REFILL (-2)
#define IDL_SCAN_ERROR (-3)
#define IDL_PARSE_ERROR IDL_SCAN_ERROR
#define IDL_MEMORY_EXHAUSTED (-5)
#define IDL_READ_ERROR (-6)

int32_t idl_lex(idl_processor_t *proc, idl_lexeme_t *lex);

int32_t idl_scan(idl_processor_t *proc, idl_token_t *tok);

int32_t idl_parse(idl_processor_t *proc);

int32_t idl_parse_directive(idl_processor_t *proc, idl_token_t *tok);

int32_t idl_parse_code(idl_processor_t *proc, idl_token_t *tok);

void idl_error(
  idl_processor_t *proc, idl_location_t *loc, const char *fmt, ...);

void idl_verror(
  idl_processor_t *proc, idl_location_t *loc, const char *fmt, va_list ap);

void idl_warning(
  idl_processor_t *proc, idl_location_t *loc, const char *fmt, ...);

int32_t idl_parse_file(const char *filename, ddsts_type_t **root);

int32_t idl_parse_string(const char *str, ddsts_type_t **root);

int32_t idl_processor_init(idl_processor_t *proc);

void idl_processor_fini(idl_processor_t *proc);

int32_t idl_parse_string(const char *str, ddsts_type_t **ref_root_type);

#endif /* IDL_H */
